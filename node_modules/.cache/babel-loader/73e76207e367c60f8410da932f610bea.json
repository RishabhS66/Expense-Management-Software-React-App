{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar updateHash = function updateHash(hash, historyUpdate) {\n  var hashVal = hash.indexOf(\"#\") === 0 ? hash.substring(1) : hash;\n  var hashToUpdate = hashVal ? \"#\" + hashVal : \"\";\n  var curLoc = window && window.location;\n  var urlToPush = hashToUpdate ? curLoc.pathname + curLoc.search + hashToUpdate : curLoc.pathname + curLoc.search;\n  historyUpdate ? history.pushState(null, \"\", urlToPush) : history.replaceState(null, \"\", urlToPush);\n};\n\nvar getHash = function getHash() {\n  return window.location.hash.replace(/^#/, \"\");\n};\n\nvar filterElementInContainer = function filterElementInContainer(container) {\n  return function (element) {\n    return container.contains ? container != element && container.contains(element) : !!(container.compareDocumentPosition(element) & 16);\n  };\n};\n\nvar isPositioned = function isPositioned(element) {\n  return getComputedStyle(element).position !== \"static\";\n};\n\nvar getElementOffsetInfoUntil = function getElementOffsetInfoUntil(element, predicate) {\n  var offsetTop = element.offsetTop;\n  var currentOffsetParent = element.offsetParent;\n\n  while (currentOffsetParent && !predicate(currentOffsetParent)) {\n    offsetTop += currentOffsetParent.offsetTop;\n    currentOffsetParent = currentOffsetParent.offsetParent;\n  }\n\n  return {\n    offsetTop: offsetTop,\n    offsetParent: currentOffsetParent\n  };\n};\n\nvar scrollOffset = function scrollOffset(c, t, horizontal) {\n  if (horizontal) {\n    return c === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(c).position !== \"static\" ? t.offsetLeft : t.offsetLeft - c.offsetLeft;\n  } else {\n    if (c === document) {\n      return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);\n    } // The offsetParent of an element, according to MDN, is its nearest positioned\n    // (an element whose position is anything other than static) ancestor. The offsetTop\n    // of an element is taken with respect to its offsetParent which may not neccessarily\n    // be its parentElement except the parent itself is positioned.\n    // So if containerElement is positioned, then it must be an offsetParent somewhere\n    // If it happens that targetElement is a descendant of the containerElement, and there\n    // is not intermediate positioned element between the two of them, i.e.\n    // targetElement\"s offsetParent is the same as the containerElement, then the\n    // distance between the two will be the offsetTop of the targetElement.\n    // If, on the other hand, there are intermediate positioned elements between the\n    // two entities, the distance between the targetElement and the containerElement\n    // will be the accumulation of the offsetTop of the element and that of its\n    // subsequent offsetParent until the containerElement is reached, since it\n    // will also be an offsetParent at some point due to the fact that it is positioned.\n    // If the containerElement is not positioned, then it can\"t be an offsetParent,\n    // which means that the offsetTop of the targetElement would not be with respect to it.\n    // However, if the two of them happen to have the same offsetParent, then\n    // the distance between them will be the difference between their offsetTop\n    // since they are both taken with respect to the same entity.\n    // The last resort would be to accumulate their offsetTop until a common\n    // offsetParent is reached (usually the document) and taking the difference\n    // between the accumulated offsetTops\n\n\n    if (isPositioned(c)) {\n      if (t.offsetParent !== c) {\n        var isContainerElementOrDocument = function isContainerElementOrDocument(e) {\n          return e === c || e === document;\n        };\n\n        var _getElementOffsetInfo = getElementOffsetInfoUntil(t, isContainerElementOrDocument),\n            offsetTop = _getElementOffsetInfo.offsetTop,\n            offsetParent = _getElementOffsetInfo.offsetParent;\n\n        if (offsetParent !== c) {\n          throw new Error(\"Seems containerElement is not an ancestor of the Element\");\n        }\n\n        return offsetTop;\n      }\n\n      return t.offsetTop;\n    }\n\n    if (t.offsetParent === c.offsetParent) {\n      return t.offsetTop - c.offsetTop;\n    }\n\n    var isDocument = function isDocument(e) {\n      return e === document;\n    };\n\n    return getElementOffsetInfoUntil(t, isDocument).offsetTop - getElementOffsetInfoUntil(c, isDocument).offsetTop;\n  }\n};\n\nexports.default = {\n  updateHash: updateHash,\n  getHash: getHash,\n  filterElementInContainer: filterElementInContainer,\n  scrollOffset: scrollOffset\n};","map":{"version":3,"sources":["/Users/rissriva/Desktop/ExpenseManagementSystem/ExpenseManagement/frontend/node_modules/react-scroll/modules/mixins/utils.js"],"names":["Object","defineProperty","exports","value","updateHash","hash","historyUpdate","hashVal","indexOf","substring","hashToUpdate","curLoc","window","location","urlToPush","pathname","search","history","pushState","replaceState","getHash","replace","filterElementInContainer","container","element","contains","compareDocumentPosition","isPositioned","getComputedStyle","position","getElementOffsetInfoUntil","predicate","offsetTop","currentOffsetParent","offsetParent","scrollOffset","c","t","horizontal","document","getBoundingClientRect","left","scrollX","pageXOffset","offsetLeft","top","scrollY","pageYOffset","isContainerElementOrDocument","e","_getElementOffsetInfo","Error","isDocument","default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar updateHash = function updateHash(hash, historyUpdate) {\n  var hashVal = hash.indexOf(\"#\") === 0 ? hash.substring(1) : hash;\n  var hashToUpdate = hashVal ? \"#\" + hashVal : \"\";\n  var curLoc = window && window.location;\n  var urlToPush = hashToUpdate ? curLoc.pathname + curLoc.search + hashToUpdate : curLoc.pathname + curLoc.search;\n  historyUpdate ? history.pushState(null, \"\", urlToPush) : history.replaceState(null, \"\", urlToPush);\n};\n\nvar getHash = function getHash() {\n  return window.location.hash.replace(/^#/, \"\");\n};\n\nvar filterElementInContainer = function filterElementInContainer(container) {\n  return function (element) {\n    return container.contains ? container != element && container.contains(element) : !!(container.compareDocumentPosition(element) & 16);\n  };\n};\n\nvar isPositioned = function isPositioned(element) {\n  return getComputedStyle(element).position !== \"static\";\n};\n\nvar getElementOffsetInfoUntil = function getElementOffsetInfoUntil(element, predicate) {\n  var offsetTop = element.offsetTop;\n  var currentOffsetParent = element.offsetParent;\n\n  while (currentOffsetParent && !predicate(currentOffsetParent)) {\n    offsetTop += currentOffsetParent.offsetTop;\n    currentOffsetParent = currentOffsetParent.offsetParent;\n  }\n\n  return { offsetTop: offsetTop, offsetParent: currentOffsetParent };\n};\n\nvar scrollOffset = function scrollOffset(c, t, horizontal) {\n  if (horizontal) {\n    return c === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(c).position !== \"static\" ? t.offsetLeft : t.offsetLeft - c.offsetLeft;\n  } else {\n    if (c === document) {\n      return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);\n    }\n\n    // The offsetParent of an element, according to MDN, is its nearest positioned\n    // (an element whose position is anything other than static) ancestor. The offsetTop\n    // of an element is taken with respect to its offsetParent which may not neccessarily\n    // be its parentElement except the parent itself is positioned.\n\n    // So if containerElement is positioned, then it must be an offsetParent somewhere\n    // If it happens that targetElement is a descendant of the containerElement, and there\n    // is not intermediate positioned element between the two of them, i.e.\n    // targetElement\"s offsetParent is the same as the containerElement, then the\n    // distance between the two will be the offsetTop of the targetElement.\n    // If, on the other hand, there are intermediate positioned elements between the\n    // two entities, the distance between the targetElement and the containerElement\n    // will be the accumulation of the offsetTop of the element and that of its\n    // subsequent offsetParent until the containerElement is reached, since it\n    // will also be an offsetParent at some point due to the fact that it is positioned.\n\n    // If the containerElement is not positioned, then it can\"t be an offsetParent,\n    // which means that the offsetTop of the targetElement would not be with respect to it.\n    // However, if the two of them happen to have the same offsetParent, then\n    // the distance between them will be the difference between their offsetTop\n    // since they are both taken with respect to the same entity.\n    // The last resort would be to accumulate their offsetTop until a common\n    // offsetParent is reached (usually the document) and taking the difference\n    // between the accumulated offsetTops\n\n    if (isPositioned(c)) {\n      if (t.offsetParent !== c) {\n        var isContainerElementOrDocument = function isContainerElementOrDocument(e) {\n          return e === c || e === document;\n        };\n\n        var _getElementOffsetInfo = getElementOffsetInfoUntil(t, isContainerElementOrDocument),\n            offsetTop = _getElementOffsetInfo.offsetTop,\n            offsetParent = _getElementOffsetInfo.offsetParent;\n\n        if (offsetParent !== c) {\n          throw new Error(\"Seems containerElement is not an ancestor of the Element\");\n        }\n\n        return offsetTop;\n      }\n\n      return t.offsetTop;\n    }\n\n    if (t.offsetParent === c.offsetParent) {\n      return t.offsetTop - c.offsetTop;\n    }\n\n    var isDocument = function isDocument(e) {\n      return e === document;\n    };\n    return getElementOffsetInfoUntil(t, isDocument).offsetTop - getElementOffsetInfoUntil(c, isDocument).offsetTop;\n  }\n};\n\nexports.default = {\n  updateHash: updateHash,\n  getHash: getHash,\n  filterElementInContainer: filterElementInContainer,\n  scrollOffset: scrollOffset\n};"]},"metadata":{},"sourceType":"script"}