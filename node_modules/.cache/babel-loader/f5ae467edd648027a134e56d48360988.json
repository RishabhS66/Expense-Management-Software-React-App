{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar DEFAULT_FILES_TO_IGNORE = ['.DS_Store', // OSX indexing file\n'Thumbs.db' // Windows indexing file\n]; // map of common (mostly media types) mime types to use when the browser does not supply the mime type\n\nvar EXTENSION_TO_MIME_TYPE_MAP = {\n  avi: 'video/avi',\n  gif: 'image/gif',\n  ico: 'image/x-icon',\n  jpeg: 'image/jpeg',\n  jpg: 'image/jpeg',\n  mkv: 'video/x-matroska',\n  mov: 'video/quicktime',\n  mp4: 'video/mp4',\n  pdf: 'application/pdf',\n  png: 'image/png',\n  zip: 'application/zip'\n};\n\nfunction shouldIgnoreFile(file) {\n  return DEFAULT_FILES_TO_IGNORE.indexOf(file.name) >= 0;\n}\n\nfunction copyString(aString) {\n  return (' ' + aString).slice(1);\n}\n\nfunction traverseDirectory(entry) {\n  var reader = entry.createReader(); // Resolved when the entire directory is traversed\n\n  return new Promise(function (resolveDirectory) {\n    var iterationAttempts = [];\n\n    var errorHandler = function errorHandler() {};\n\n    function readEntries() {\n      // According to the FileSystem API spec, readEntries() must be called until\n      // it calls the callback with an empty array.\n      reader.readEntries(function (batchEntries) {\n        if (!batchEntries.length) {\n          // Done iterating this particular directory\n          resolveDirectory(Promise.all(iterationAttempts));\n        } else {\n          // Add a list of promises for each directory entry.  If the entry is itself\n          // a directory, then that promise won't resolve until it is fully traversed.\n          iterationAttempts.push(Promise.all(batchEntries.map(function (batchEntry) {\n            if (batchEntry.isDirectory) {\n              return traverseDirectory(batchEntry);\n            }\n\n            return Promise.resolve(batchEntry);\n          }))); // Try calling readEntries() again for the same dir, according to spec\n\n          readEntries();\n        }\n      }, errorHandler);\n    } // initial call to recursive entry reader function\n\n\n    readEntries();\n  });\n} // package the file in an object that includes the fullPath from the file entry\n// that would otherwise be lost\n\n\nfunction packageFile(file, entry) {\n  var fileTypeOverride = ''; // handle some browsers sometimes missing mime types for dropped files\n\n  var hasExtension = file.name && file.name.lastIndexOf('.') !== -1;\n\n  if (hasExtension && !file.type) {\n    var fileExtension = (file.name || '').split('.').pop();\n    fileTypeOverride = EXTENSION_TO_MIME_TYPE_MAP[fileExtension];\n  }\n\n  return {\n    fileObject: file,\n    // provide access to the raw File object (required for uploading)\n    fullPath: entry ? copyString(entry.fullPath) : file.name,\n    lastModified: file.lastModified,\n    lastModifiedDate: file.lastModifiedDate,\n    name: file.name,\n    size: file.size,\n    type: file.type ? file.type : fileTypeOverride,\n    webkitRelativePath: file.webkitRelativePath\n  };\n}\n\nfunction getFile(entry) {\n  return new Promise(function (resolve) {\n    entry.file(function (file) {\n      resolve(packageFile(file, entry));\n    });\n  });\n}\n\nfunction handleFilePromises(promises, fileList) {\n  return Promise.all(promises).then(function (files) {\n    files.forEach(function (file) {\n      if (!shouldIgnoreFile(file)) {\n        fileList.push(file);\n      }\n    });\n    return fileList;\n  });\n}\n\nfunction getDataTransferFiles(dataTransfer) {\n  var dataTransferFiles = [];\n  var folderPromises = [];\n  var filePromises = [];\n  [].slice.call(dataTransfer.items).forEach(function (listItem) {\n    if (typeof listItem.webkitGetAsEntry === 'function') {\n      var entry = listItem.webkitGetAsEntry();\n\n      if (entry) {\n        if (entry.isDirectory) {\n          folderPromises.push(traverseDirectory(entry));\n        } else {\n          filePromises.push(getFile(entry));\n        }\n      }\n    } else {\n      dataTransferFiles.push(listItem);\n    }\n  });\n\n  if (folderPromises.length) {\n    var flatten = function flatten(array) {\n      return array.reduce(function (a, b) {\n        return a.concat(Array.isArray(b) ? flatten(b) : b);\n      }, []);\n    };\n\n    return Promise.all(folderPromises).then(function (fileEntries) {\n      var flattenedEntries = flatten(fileEntries); // collect async promises to convert each fileEntry into a File object\n\n      flattenedEntries.forEach(function (fileEntry) {\n        filePromises.push(getFile(fileEntry));\n      });\n      return handleFilePromises(filePromises, dataTransferFiles);\n    });\n  } else if (filePromises.length) {\n    return handleFilePromises(filePromises, dataTransferFiles);\n  }\n\n  return Promise.resolve(dataTransferFiles);\n}\n/**\n * This function should be called from both the onDrop event from your drag/drop\n * dropzone as well as from the HTML5 file selector input field onChange event\n * handler.  Pass the event object from the triggered event into this function.\n * Supports mix of files and folders dropped via drag/drop.\n *\n * Returns: an array of File objects, that includes all files within folders\n *   and subfolders of the dropped/selected items.\n */\n\n\nfunction getDroppedOrSelectedFiles(event) {\n  var dataTransfer = event.dataTransfer;\n\n  if (dataTransfer && dataTransfer.items) {\n    return getDataTransferFiles(dataTransfer).then(function (fileList) {\n      return Promise.resolve(fileList);\n    });\n  }\n\n  var files = [];\n  var dragDropFileList = dataTransfer && dataTransfer.files;\n  var inputFieldFileList = event.target && event.target.files;\n  var fileList = dragDropFileList || inputFieldFileList || []; // convert the FileList to a simple array of File objects\n\n  for (var i = 0; i < fileList.length; i++) {\n    files.push(packageFile(fileList[i]));\n  }\n\n  return Promise.resolve(files);\n}\n/**\n * Html5 File Selector\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\n\nexports.getDataTransferFiles = getDataTransferFiles;\nexports.getDroppedOrSelectedFiles = getDroppedOrSelectedFiles;","map":{"version":3,"sources":["../src/Html5FileSelector.js","../src/index.js"],"names":["DEFAULT_FILES_TO_IGNORE","EXTENSION_TO_MIME_TYPE_MAP","file","reader","entry","iterationAttempts","errorHandler","batchEntries","Promise","batchEntry","traverseDirectory","fileTypeOverride","hasExtension","fileExtension","copyString","webkitRelativePath","packageFile","shouldIgnoreFile","dataTransferFiles","folderPromises","filePromises","dataTransfer","listItem","getFile","flatten","a","Array","flattenedEntries","handleFilePromises","event","files","dragDropFileList","inputFieldFileList","fileList","i"],"mappings":";;;;;AAAA,IAAMA,uBAAAA,GAA0B,CAAA,WAAA,EAAA;AAAA,WAAA,CAAA;AAAA,CAAhC,C;;AAMA,IAAMC,0BAAAA,GAA6B;OAAA,WAAA;OAAA,WAAA;OAAA,cAAA;QAAA,YAAA;OAAA,YAAA;OAAA,kBAAA;OAAA,iBAAA;OAAA,WAAA;OAAA,iBAAA;OAAA,WAAA;OAW5B;AAX4B,CAAnC;;AAcA,SAAA,gBAAA,CAAA,IAAA,EAAgC;SACvBD,uBAAAA,CAAAA,OAAAA,CAAgCE,IAAAA,CAAhCF,IAAAA,KAAP,C;;;AAGF,SAAA,UAAA,CAAA,OAAA,EAA6B;SACpB,CAAA,MAAA,OAAA,EAAA,KAAA,CAAP,CAAO,C;;;AAGT,SAAA,iBAAA,CAAA,KAAA,EAAkC;MAC1BG,MAAAA,GAASC,KAAAA,CAAf,YAAeA,E,CADiB,C;;SAGzB,IAAA,OAAA,CAAY,UAAA,gBAAA,EAAsB;QACjCC,iBAAAA,GAAN,E;;QACMC,YAAAA,GAAe,SAAfA,YAAe,GAAM,CAA3B,C;;aACA,W,GAAuB;;;aAGrB,W,CAAmB,UAAA,YAAA,EAAkB;YAC/B,CAACC,YAAAA,CAAL,M,EAA0B;;2BAEPC,OAAAA,CAAAA,GAAAA,CAAjB,iBAAiBA,C;AAFnB,S,MAGO;;;4BAGL,I,CAAuB,OAAA,CAAA,GAAA,CAAY,YAAA,CAAA,GAAA,CAAiB,UAAA,UAAA,EAAgB;gBAC9DC,UAAAA,CAAJ,W,EAA4B;qBACnBC,iBAAAA,CAAP,UAAOA,C;;;mBAEFF,OAAAA,CAAAA,OAAAA,CAAP,UAAOA,C;AAJT,WAAmC,CAAZ,C,EAHlB,C;;;;AAJT,O,EAAA,Y;KANqC,C;;;;AAAzC,GAAO,C;;;;;AA+BT,SAAA,WAAA,CAAA,IAAA,EAAA,KAAA,EAAkC;MAC5BG,gBAAAA,GAAJ,E,CADgC,C;;MAG1BC,YAAAA,GAAeV,IAAAA,CAAAA,IAAAA,IAAaA,IAAAA,CAAAA,IAAAA,CAAAA,WAAAA,CAAAA,GAAAA,MAA+B,CAAjE,C;;MACIU,YAAAA,IAAgB,CAACV,IAAAA,CAArB,I,EAAgC;QACxBW,aAAAA,GAAgB,CAACX,IAAAA,CAAAA,IAAAA,IAAD,EAAA,EAAA,KAAA,CAAA,GAAA,EAAtB,GAAsB,E;uBACHD,0BAAAA,CAAnB,aAAmBA,C;;;SAEd;gBAAA,IAAA;AAAA;cAEKG,KAAAA,GAAQU,UAAAA,CAAWV,KAAAA,CAAnBA,QAAQU,CAARV,GAAqCF,IAAAA,CAF1C,IAAA;kBAGSA,IAAAA,CAHT,YAAA;sBAIaA,IAAAA,CAJb,gBAAA;UAKCA,IAAAA,CALD,IAAA;UAMCA,IAAAA,CAND,IAAA;UAOCA,IAAAA,CAAAA,IAAAA,GAAYA,IAAAA,CAAZA,IAAAA,GAPD,gBAAA;wBAQeA,IAAAA,CAAKa;AARpB,G;;;AAYT,SAAA,OAAA,CAAA,KAAA,EAAwB;SACf,IAAA,OAAA,CAAY,UAAA,OAAA,EAAa;UAC9B,I,CAAW,UAAA,IAAA,EAAU;cACXC,WAAAA,CAAAA,IAAAA,EAAR,KAAQA,C;AADV,K;AADF,GAAO,C;;;AAOT,SAAA,kBAAA,CAAA,QAAA,EAAA,QAAA,EAAgD;SACvC,OAAA,CAAA,GAAA,CAAA,QAAA,EAAA,IAAA,CAA2B,UAAA,KAAA,EAAW;UAC3C,O,CAAc,UAAA,IAAA,EAAU;UAClB,CAACC,gBAAAA,CAAL,IAAKA,C,EAAwB;iBAC3B,I,CAAA,I;;AAFJ,K;WAKA,Q;AANF,GAAO,C;;;AAUF,SAAA,oBAAA,CAAA,YAAA,EAA4C;MAC3CC,iBAAAA,GAAN,E;MACMC,cAAAA,GAAN,E;MACMC,YAAAA,GAAN,E;KAEA,K,CAAA,I,CAAcC,YAAAA,CAAd,K,EAAA,O,CAA0C,UAAA,QAAA,EAAc;QAClD,OAAOC,QAAAA,CAAP,gBAAA,KAAJ,U,EAAqD;UAC7ClB,KAAAA,GAAQkB,QAAAA,CAAd,gBAAcA,E;;UAEd,K,EAAW;YACLlB,KAAAA,CAAJ,W,EAAuB;yBACrB,I,CAAoBM,iBAAAA,CAApB,KAAoBA,C;AADtB,S,MAEO;uBACL,I,CAAkBa,OAAAA,CAAlB,KAAkBA,C;;;AAPxB,K,MAUO;wBACL,I,CAAA,Q;;AAZJ,G;;MAeIJ,cAAAA,CAAJ,M,EAA2B;QACnBK,OAAAA,GAAU,SAAVA,OAAU,CAAA,KAAA,EAAA;aAAW,KAAA,CAAA,MAAA,CAAa,UAAA,CAAA,EAAA,CAAA,EAAA;eAAUC,CAAAA,CAAAA,MAAAA,CAASC,KAAAA,CAAAA,OAAAA,CAAAA,CAAAA,IAAmBF,OAAAA,CAAnBE,CAAmBF,CAAnBE,GAAnB,CAAUD,C;AAAvB,OAAA,EAAX,EAAW,C;AAA3B,K;;WACO,OAAA,CAAA,GAAA,CAAA,cAAA,EAAA,IAAA,CAAiC,UAAA,WAAA,EAAiB;UACjDE,gBAAAA,GAAmBH,OAAAA,CAAzB,WAAyBA,C,CAD8B,C;;uBAGvD,O,CAAyB,UAAA,SAAA,EAAe;qBACtC,I,CAAkBD,OAAAA,CAAlB,SAAkBA,C;AADpB,O;aAGOK,kBAAAA,CAAAA,YAAAA,EAAP,iBAAOA,C;AANT,KAAO,C;AAFT,G,MAUO,IAAIR,YAAAA,CAAJ,MAAA,EAAyB;WACvBQ,kBAAAA,CAAAA,YAAAA,EAAP,iBAAOA,C;;;SAEFpB,OAAAA,CAAAA,OAAAA,CAAP,iBAAOA,C;;;;;;;;;;;;;AAYF,SAAA,yBAAA,CAAA,KAAA,EAA0C;MACzCa,YAAAA,GAAeQ,KAAAA,CAArB,Y;;MACIR,YAAAA,IAAgBA,YAAAA,CAApB,K,EAAwC;WAC/B,oBAAA,CAAA,YAAA,CAAA,CAAA,IAAA,CAAwC,UAAA,QAAA,EAAc;aACpDb,OAAAA,CAAAA,OAAAA,CAAP,QAAOA,C;AADT,KAAO,C;;;MAIHsB,KAAAA,GAAN,E;MACMC,gBAAAA,GAAmBV,YAAAA,IAAgBA,YAAAA,CAAzC,K;MACMW,kBAAAA,GAAqBH,KAAAA,CAAAA,MAAAA,IAAgBA,KAAAA,CAAAA,MAAAA,CAA3C,K;MACMI,QAAAA,GAAWF,gBAAAA,IAAAA,kBAAAA,IAAjB,E,CAV+C,C;;OAY1C,IAAIG,CAAAA,GAAT,C,EAAgBA,CAAAA,GAAID,QAAAA,CAApB,M,EAAqCC,CAArC,E,EAA0C;UACxC,I,CAAWlB,WAAAA,CAAYiB,QAAAA,CAAvB,CAAuBA,CAAZjB,C;;;SAENR,OAAAA,CAAAA,OAAAA,CAAP,KAAOA,C;;ACjKT;;;;;AAOA","sourcesContent":["const DEFAULT_FILES_TO_IGNORE = [\n  '.DS_Store', // OSX indexing file\n  'Thumbs.db'  // Windows indexing file\n];\n\n// map of common (mostly media types) mime types to use when the browser does not supply the mime type\nconst EXTENSION_TO_MIME_TYPE_MAP = {\n  avi: 'video/avi',\n  gif: 'image/gif',\n  ico: 'image/x-icon',\n  jpeg: 'image/jpeg',\n  jpg: 'image/jpeg',\n  mkv: 'video/x-matroska',\n  mov: 'video/quicktime',\n  mp4: 'video/mp4',\n  pdf: 'application/pdf',\n  png: 'image/png',\n  zip: 'application/zip'\n};\n\nfunction shouldIgnoreFile(file) {\n  return DEFAULT_FILES_TO_IGNORE.indexOf(file.name) >= 0;\n}\n\nfunction copyString(aString) {\n  return ` ${aString}`.slice(1);\n}\n\nfunction traverseDirectory(entry) {\n  const reader = entry.createReader();\n  // Resolved when the entire directory is traversed\n  return new Promise((resolveDirectory) => {\n    const iterationAttempts = [];\n    const errorHandler = () => {};\n    function readEntries() {\n      // According to the FileSystem API spec, readEntries() must be called until\n      // it calls the callback with an empty array.\n      reader.readEntries((batchEntries) => {\n        if (!batchEntries.length) {\n          // Done iterating this particular directory\n          resolveDirectory(Promise.all(iterationAttempts));\n        } else {\n          // Add a list of promises for each directory entry.  If the entry is itself\n          // a directory, then that promise won't resolve until it is fully traversed.\n          iterationAttempts.push(Promise.all(batchEntries.map((batchEntry) => {\n            if (batchEntry.isDirectory) {\n              return traverseDirectory(batchEntry);\n            }\n            return Promise.resolve(batchEntry);\n          })));\n          // Try calling readEntries() again for the same dir, according to spec\n          readEntries();\n        }\n      }, errorHandler);\n    }\n    // initial call to recursive entry reader function\n    readEntries();\n  });\n}\n\n// package the file in an object that includes the fullPath from the file entry\n// that would otherwise be lost\nfunction packageFile(file, entry) {\n  let fileTypeOverride = '';\n  // handle some browsers sometimes missing mime types for dropped files\n  const hasExtension = file.name && file.name.lastIndexOf('.') !== -1;\n  if (hasExtension && !file.type) {\n    const fileExtension = (file.name || '').split('.').pop();\n    fileTypeOverride = EXTENSION_TO_MIME_TYPE_MAP[fileExtension];\n  }\n  return {\n    fileObject: file, // provide access to the raw File object (required for uploading)\n    fullPath: entry ? copyString(entry.fullPath) : file.name,\n    lastModified: file.lastModified,\n    lastModifiedDate: file.lastModifiedDate,\n    name: file.name,\n    size: file.size,\n    type: file.type ? file.type : fileTypeOverride,\n    webkitRelativePath: file.webkitRelativePath\n  };\n}\n\nfunction getFile(entry) {\n  return new Promise((resolve) => {\n    entry.file((file) => {\n      resolve(packageFile(file, entry));\n    });\n  });\n}\n\nfunction handleFilePromises(promises, fileList) {\n  return Promise.all(promises).then((files) => {\n    files.forEach((file) => {\n      if (!shouldIgnoreFile(file)) {\n        fileList.push(file);\n      }\n    });\n    return fileList;\n  });\n}\n\nexport function getDataTransferFiles(dataTransfer) {\n  const dataTransferFiles = [];\n  const folderPromises = [];\n  const filePromises = [];\n\n  [].slice.call(dataTransfer.items).forEach((listItem) => {\n    if (typeof listItem.webkitGetAsEntry === 'function') {\n      const entry = listItem.webkitGetAsEntry();\n\n      if (entry) {\n        if (entry.isDirectory) {\n          folderPromises.push(traverseDirectory(entry));\n        } else {\n          filePromises.push(getFile(entry));\n        }\n      }\n    } else {\n      dataTransferFiles.push(listItem);\n    }\n  });\n  if (folderPromises.length) {\n    const flatten = (array) => array.reduce((a, b) => a.concat(Array.isArray(b) ? flatten(b) : b), []);\n    return Promise.all(folderPromises).then((fileEntries) => {\n      const flattenedEntries = flatten(fileEntries);\n      // collect async promises to convert each fileEntry into a File object\n      flattenedEntries.forEach((fileEntry) => {\n        filePromises.push(getFile(fileEntry));\n      });\n      return handleFilePromises(filePromises, dataTransferFiles);\n    });\n  } else if (filePromises.length) {\n    return handleFilePromises(filePromises, dataTransferFiles);\n  }\n  return Promise.resolve(dataTransferFiles);\n}\n\n/**\n * This function should be called from both the onDrop event from your drag/drop\n * dropzone as well as from the HTML5 file selector input field onChange event\n * handler.  Pass the event object from the triggered event into this function.\n * Supports mix of files and folders dropped via drag/drop.\n *\n * Returns: an array of File objects, that includes all files within folders\n *   and subfolders of the dropped/selected items.\n */\nexport function getDroppedOrSelectedFiles(event) {\n  const dataTransfer = event.dataTransfer;\n  if (dataTransfer && dataTransfer.items) {\n    return getDataTransferFiles(dataTransfer).then((fileList) => {\n      return Promise.resolve(fileList);\n    });\n  }\n  const files = [];\n  const dragDropFileList = dataTransfer && dataTransfer.files;\n  const inputFieldFileList = event.target && event.target.files;\n  const fileList = dragDropFileList || inputFieldFileList || [];\n  // convert the FileList to a simple array of File objects\n  for (let i = 0; i < fileList.length; i++) {\n    files.push(packageFile(fileList[i]));\n  }\n  return Promise.resolve(files);\n}\n","/**\n * Html5 File Selector\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nexport { getDataTransferFiles, getDroppedOrSelectedFiles } from './Html5FileSelector.js';\n"]},"metadata":{},"sourceType":"script"}