{"ast":null,"code":"var candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable=\"false\"])'];\nvar candidateSelector = candidateSelectors.join(',');\nvar matches = typeof Element === 'undefined' ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n\nfunction tabbable(el, options) {\n  options = options || {};\n  var regularTabbables = [];\n  var orderedTabbables = [];\n  var candidates = el.querySelectorAll(candidateSelector);\n\n  if (options.includeContainer) {\n    if (matches.call(el, candidateSelector)) {\n      candidates = Array.prototype.slice.apply(candidates);\n      candidates.unshift(el);\n    }\n  }\n\n  var i, candidate, candidateTabindex;\n\n  for (i = 0; i < candidates.length; i++) {\n    candidate = candidates[i];\n    if (!isNodeMatchingSelectorTabbable(candidate)) continue;\n    candidateTabindex = getTabindex(candidate);\n\n    if (candidateTabindex === 0) {\n      regularTabbables.push(candidate);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        node: candidate\n      });\n    }\n  }\n\n  var tabbableNodes = orderedTabbables.sort(sortOrderedTabbables).map(function (a) {\n    return a.node;\n  }).concat(regularTabbables);\n  return tabbableNodes;\n}\n\ntabbable.isTabbable = isTabbable;\ntabbable.isFocusable = isFocusable;\n\nfunction isNodeMatchingSelectorTabbable(node) {\n  if (!isNodeMatchingSelectorFocusable(node) || isNonTabbableRadio(node) || getTabindex(node) < 0) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isTabbable(node) {\n  if (!node) throw new Error('No node provided');\n  if (matches.call(node, candidateSelector) === false) return false;\n  return isNodeMatchingSelectorTabbable(node);\n}\n\nfunction isNodeMatchingSelectorFocusable(node) {\n  if (node.disabled || isHiddenInput(node) || isHidden(node)) {\n    return false;\n  }\n\n  return true;\n}\n\nvar focusableCandidateSelector = candidateSelectors.concat('iframe').join(',');\n\nfunction isFocusable(node) {\n  if (!node) throw new Error('No node provided');\n  if (matches.call(node, focusableCandidateSelector) === false) return false;\n  return isNodeMatchingSelectorFocusable(node);\n}\n\nfunction getTabindex(node) {\n  var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n  if (!isNaN(tabindexAttr)) return tabindexAttr; // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n\n  if (isContentEditable(node)) return 0;\n  return node.tabIndex;\n}\n\nfunction sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n}\n\nfunction isContentEditable(node) {\n  return node.contentEditable === 'true';\n}\n\nfunction isInput(node) {\n  return node.tagName === 'INPUT';\n}\n\nfunction isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n}\n\nfunction isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n}\n\nfunction isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n}\n\nfunction getCheckedRadio(nodes) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked) {\n      return nodes[i];\n    }\n  }\n}\n\nfunction isTabbableRadio(node) {\n  if (!node.name) return true; // This won't account for the edge case where you have radio groups with the same\n  // in separate forms on the same page.\n\n  var radioSet = node.ownerDocument.querySelectorAll('input[type=\"radio\"][name=\"' + node.name + '\"]');\n  var checked = getCheckedRadio(radioSet);\n  return !checked || checked === node;\n}\n\nfunction isHidden(node) {\n  // offsetParent being null will allow detecting cases where an element is invisible or inside an invisible element,\n  // as long as the element does not use position: fixed. For them, their visibility has to be checked directly as well.\n  return node.offsetParent === null || getComputedStyle(node).visibility === 'hidden';\n}\n\nmodule.exports = tabbable;","map":{"version":3,"sources":["/Users/rissriva/Desktop/ExpenseManagementSystem/ExpenseManagement/frontend/node_modules/tabbable/index.js"],"names":["candidateSelectors","candidateSelector","join","matches","Element","prototype","msMatchesSelector","webkitMatchesSelector","tabbable","el","options","regularTabbables","orderedTabbables","candidates","querySelectorAll","includeContainer","call","Array","slice","apply","unshift","i","candidate","candidateTabindex","length","isNodeMatchingSelectorTabbable","getTabindex","push","documentOrder","tabIndex","node","tabbableNodes","sort","sortOrderedTabbables","map","a","concat","isTabbable","isFocusable","isNodeMatchingSelectorFocusable","isNonTabbableRadio","Error","disabled","isHiddenInput","isHidden","focusableCandidateSelector","tabindexAttr","parseInt","getAttribute","isNaN","isContentEditable","b","contentEditable","isInput","tagName","type","isRadio","isTabbableRadio","getCheckedRadio","nodes","checked","name","radioSet","ownerDocument","offsetParent","getComputedStyle","visibility","module","exports"],"mappings":"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","sourcesContent":["var candidateSelectors = [\n  'input',\n  'select',\n  'textarea',\n  'a[href]',\n  'button',\n  '[tabindex]',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]:not([contenteditable=\"false\"])',\n];\nvar candidateSelector = candidateSelectors.join(',');\n\nvar matches = typeof Element === 'undefined'\n  ? function () {}\n  : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n\nfunction tabbable(el, options) {\n  options = options || {};\n\n  var regularTabbables = [];\n  var orderedTabbables = [];\n\n  var candidates = el.querySelectorAll(candidateSelector);\n\n  if (options.includeContainer) {\n    if (matches.call(el, candidateSelector)) {\n      candidates = Array.prototype.slice.apply(candidates);\n      candidates.unshift(el);\n    }\n  }\n\n  var i, candidate, candidateTabindex;\n  for (i = 0; i < candidates.length; i++) {\n    candidate = candidates[i];\n\n    if (!isNodeMatchingSelectorTabbable(candidate)) continue;\n\n    candidateTabindex = getTabindex(candidate);\n    if (candidateTabindex === 0) {\n      regularTabbables.push(candidate);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        node: candidate,\n      });\n    }\n  }\n\n  var tabbableNodes = orderedTabbables\n    .sort(sortOrderedTabbables)\n    .map(function(a) { return a.node })\n    .concat(regularTabbables);\n\n  return tabbableNodes;\n}\n\ntabbable.isTabbable = isTabbable;\ntabbable.isFocusable = isFocusable;\n\nfunction isNodeMatchingSelectorTabbable(node) {\n  if (\n    !isNodeMatchingSelectorFocusable(node)\n    || isNonTabbableRadio(node)\n    || getTabindex(node) < 0\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction isTabbable(node) {\n  if (!node) throw new Error('No node provided');\n  if (matches.call(node, candidateSelector) === false) return false;\n  return isNodeMatchingSelectorTabbable(node);\n}\n\nfunction isNodeMatchingSelectorFocusable(node) {\n  if (\n    node.disabled\n    || isHiddenInput(node)\n    || isHidden(node)\n  ) {\n    return false;\n  }\n  return true;\n}\n\nvar focusableCandidateSelector = candidateSelectors.concat('iframe').join(',');\nfunction isFocusable(node) {\n  if (!node) throw new Error('No node provided');\n  if (matches.call(node, focusableCandidateSelector) === false) return false;\n  return isNodeMatchingSelectorFocusable(node);\n}\n\nfunction getTabindex(node) {\n  var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n  if (!isNaN(tabindexAttr)) return tabindexAttr;\n  // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n  if (isContentEditable(node)) return 0;\n  return node.tabIndex;\n}\n\nfunction sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n}\n\nfunction isContentEditable(node) {\n  return node.contentEditable === 'true';\n}\n\nfunction isInput(node) {\n  return node.tagName === 'INPUT';\n}\n\nfunction isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n}\n\nfunction isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n}\n\nfunction isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n}\n\nfunction getCheckedRadio(nodes) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked) {\n      return nodes[i];\n    }\n  }\n}\n\nfunction isTabbableRadio(node) {\n  if (!node.name) return true;\n  // This won't account for the edge case where you have radio groups with the same\n  // in separate forms on the same page.\n  var radioSet = node.ownerDocument.querySelectorAll('input[type=\"radio\"][name=\"' + node.name + '\"]');\n  var checked = getCheckedRadio(radioSet);\n  return !checked || checked === node;\n}\n\nfunction isHidden(node) {\n  // offsetParent being null will allow detecting cases where an element is invisible or inside an invisible element,\n  // as long as the element does not use position: fixed. For them, their visibility has to be checked directly as well.\n  return node.offsetParent === null || getComputedStyle(node).visibility === 'hidden';\n}\n\nmodule.exports = tabbable;\n"]},"metadata":{},"sourceType":"script"}